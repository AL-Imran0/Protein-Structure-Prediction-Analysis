# -*- coding: utf-8 -*-
"""Protein Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kPcCekG-NjQsxfJqDcIdop-5294Tibxt
"""

# ================================================================
# üß¨ Protein Structure Prediction & Analysis ‚Äî Fixed Colab Version
# ================================================================

# ---------------------------
# 0) Install dependencies
# ---------------------------
!pip install -q biopython py3Dmol scikit-learn matplotlib pandas torch seaborn einops
!pip install -q git+https://github.com/facebookresearch/esm.git
!pip install -q openfold

# ---------------------------
# 1) Imports
# ---------------------------
import os, math, random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from numpy.linalg import svd
from sklearn.decomposition import PCA
from collections import Counter
from Bio.PDB import PDBParser

# Optional py3Dmol
try: import py3Dmol; HAVE_PY3DMOL=True
except: HAVE_PY3DMOL=False

# Try ESMFold
ESM_AVAILABLE=False
try:
    import esm, torch
    ESM_AVAILABLE=True
except:
    print("‚ö†Ô∏è ESM not available; using mock predictor.")

# ---------------------------
# 2) Synthetic dataset & preprocessing
# ---------------------------
AMINO_ACIDS=list('ACDEFGHIKLMNPQRSTVWY')
random.seed(42); np.random.seed(42)

def random_protein_sequence(length):
    return ''.join(random.choices(AMINO_ACIDS, k=length))

# Generate sequences
lengths=[60,80,100,120]
sequences=[random_protein_sequence(L) for L in lengths]

# Preprocessing: remove duplicates & length filtering
def filter_sequences(seqs,min_len=50,max_len=150):
    seqs_unique=list(dict.fromkeys(seqs))
    return [s for s in seqs_unique if min_len<=len(s)<=max_len]

sequences_filtered=filter_sequences(sequences)
print(f"Filtered {len(sequences_filtered)} sequences from {len(sequences)} original")

# Feature extraction
def amino_acid_composition(seq):
    counts=Counter(seq)
    total=len(seq)
    return {aa:counts.get(aa,0)/total for aa in AMINO_ACIDS}

def sequence_features(seqs):
    feats=[]
    for s in seqs:
        aac=amino_acid_composition(s)
        hydrophobic=sum([aac[a] for a in 'AILMFV'])
        charged=sum([aac[a] for a in 'KRDE'])
        feats.append({'length':len(s),'hydrophobic_fraction':hydrophobic,'charged_fraction':charged,**aac})
    return pd.DataFrame(feats)

seq_feat_df=sequence_features(sequences_filtered)
print(seq_feat_df.head())

# ---------------------------
# 3) Utilities: PDB handling
# ---------------------------
AA3={'A':'ALA','C':'CYS','D':'ASP','E':'GLU','F':'PHE','G':'GLY','H':'HIS','I':'ILE',
     'K':'LYS','L':'LEU','M':'MET','N':'ASN','P':'PRO','Q':'GLN','R':'ARG','S':'SER',
     'T':'THR','V':'VAL','W':'TRP','Y':'TYR'}

def coords_to_pdb(coords,seq,chain_id='A'):
    lines=[]
    for i,(x,y,z) in enumerate(coords,start=1):
        three=AA3.get(seq[i-1],'ALA')
        lines.append(f"ATOM  {i:5d}  CA  {three} {chain_id}{i:4d}    {x:8.3f}{y:8.3f}{z:8.3f}  1.00  0.00           C")
    return "\n".join(lines)+"\nEND\n"

def pdb_to_ca_coords(pdb_str):
    coords=[]
    for line in pdb_str.splitlines():
        if line.startswith("ATOM") and line[12:16].strip()=="CA":
            x,y,z=map(float,[line[30:38],line[38:46],line[46:54]])
            coords.append([x,y,z])
    return np.array(coords)

# ---------------------------
# 4) Structure prediction (ESMFold or mock)
# ---------------------------
predicted_pdbs={}

if ESM_AVAILABLE:
    try:
        device=torch.device("cuda" if torch.cuda.is_available() else "cpu")
        model=esm.pretrained.esmfold_v1().eval().to(device)
        for i,seq in enumerate(sequences_filtered,1):
            key=f"SEQ{i}"
            print(f"Predicting {key}...")
            predicted_pdbs[key]=model.infer_pdbs([seq])[0]
    except Exception as e:
        print("‚ö†Ô∏è ESMFold failed, using mock predictor:", e)
        ESM_AVAILABLE=False

if not ESM_AVAILABLE:
    # Mock predictor
    def mock_coords(seq):
        n=len(seq);coords=np.zeros((n,3))
        for i in range(n):
            theta=i*(100*np.pi/180)
            coords[i]=[2.3*np.cos(theta),2.3*np.sin(theta),1.5*i]
        coords+=np.random.normal(scale=0.3,size=coords.shape)
        return coords
    for i,seq in enumerate(sequences_filtered,1):
        coords=mock_coords(seq)
        predicted_pdbs[f"SEQ{i}"]=coords_to_pdb(coords,seq)

# ---------------------------
# 5) Experimental noisy PDBs
# ---------------------------
def random_rotation():
    u=np.random.normal(size=3);u/=np.linalg.norm(u)
    angle=np.random.uniform(-0.2,0.2)
    K=np.array([[0,-u[2],u[1]],[u[2],0,-u[0]],[-u[1],u[0],0]])
    return np.eye(3)+math.sin(angle)*K+(1-math.cos(angle))*(K@K)

experimental_pdbs={}
for i,(key,pdb) in enumerate(predicted_pdbs.items()):
    P=pdb_to_ca_coords(pdb)
    noise=np.random.normal(scale=1.0,size=P.shape)
    R=random_rotation()
    Q=(P@R.T)+noise
    seq=sequences_filtered[i]
    experimental_pdbs[key]=coords_to_pdb(Q,seq)

# ---------------------------
# 6) Kabsch RMSD & per-residue distances
# ---------------------------
def kabsch_rmsd(P,Q):
    P-=P.mean(0); Q-=Q.mean(0)
    V,S,Wt=svd(P.T@Q)
    U=V@np.diag([1,1,np.sign(np.linalg.det(V@Wt))])@Wt
    P_aligned=P@U
    return np.sqrt(((P_aligned-Q)**2).sum()/P.shape[0])

rows=[]
per_residue={}
for key in predicted_pdbs:
    P=pdb_to_ca_coords(predicted_pdbs[key])
    Q=pdb_to_ca_coords(experimental_pdbs[key])
    if P.shape==Q.shape and len(P)>0:
        rmsd=kabsch_rmsd(P.copy(),Q.copy())
        P_cent=P-P.mean(0);Q_cent=Q-Q.mean(0)
        V,S,Wt=svd(P_cent.T@Q_cent)
        U=V@np.diag([1,1,np.sign(np.linalg.det(V@Wt))])@Wt
        P_rot=P_cent@U+Q.mean(0)
        per_residue[key]=np.linalg.norm(P_rot-Q,axis=1)
    else: rmsd=None
    rows.append({"sequence":key,"rmsd":rmsd,"length":len(P)})

summary=pd.DataFrame(rows)
os.makedirs("outputs",exist_ok=True)
summary.to_csv("outputs/summary.csv",index=False)
print(summary)

# ---------------------------
# 7) Visualizations
# ---------------------------
plt.figure(figsize=(10,4))
plt.subplot(1,2,1);plt.bar(summary["sequence"],summary["rmsd"]);plt.ylabel("RMSD (√Ö)");plt.title("RMSD per Sequence")
plt.subplot(1,2,2);plt.hist(summary["rmsd"].dropna());plt.xlabel("RMSD (√Ö)");plt.title("RMSD Distribution")
plt.tight_layout();plt.savefig("outputs/rmsd.png",dpi=150);plt.show()

plt.figure();plt.boxplot(summary["rmsd"].dropna());plt.ylabel("RMSD (√Ö)");plt.title("RMSD Boxplot")
plt.savefig("outputs/rmsd_box.png",dpi=150);plt.show()

# ---------------------------
# 8) Correlation heatmap (numeric columns only)
# ---------------------------
full_df=seq_feat_df.copy()
full_df['rmsd']=summary['rmsd'].values
numeric_df=full_df.select_dtypes(include=[np.number])  # drop non-numeric columns
corr=numeric_df.corr()
plt.figure(figsize=(10,8));sns.heatmap(corr,annot=True,cmap='coolwarm');plt.title("Correlation Features vs RMSD")
plt.savefig("outputs/correlation.png",dpi=150);plt.show()

# ---------------------------
# 9) Per-residue & PCA plots
# ---------------------------
os.makedirs("outputs/per_residue_plots",exist_ok=True)
os.makedirs("outputs/pca3d_plots",exist_ok=True)

for key in predicted_pdbs:
    P=pdb_to_ca_coords(predicted_pdbs[key])
    Q=pdb_to_ca_coords(experimental_pdbs[key])
    if key in per_residue and len(P)>2:
        plt.figure(figsize=(10,3))
        plt.plot(per_residue[key], marker='o', linestyle='-', color='blue')
        plt.title(f'Per-residue CA Distance: {key}')
        plt.xlabel('Residue Index');plt.ylabel('Distance (√Ö)');plt.grid(True)
        plt.savefig(f"outputs/per_residue_plots/{key}_per_residue.png", dpi=150)
        plt.close()

        combined=np.vstack([P,Q])
        proj=PCA(n_components=3).fit_transform(combined)
        projP=proj[:P.shape[0]];projQ=proj[P.shape[0]:]
        fig=plt.figure(figsize=(6,5))
        ax=fig.add_subplot(111,projection='3d')
        ax.scatter(projP[:,0],projP[:,1],projP[:,2],c='r',label='Predicted',s=30)
        ax.scatter(projQ[:,0],projQ[:,1],projQ[:,2],c='g',label='Experimental',s=30)
        ax.set_title(f'3D PCA of CA coords: {key}');ax.legend()
        plt.savefig(f"outputs/pca3d_plots/{key}_pca3d.png", dpi=150);plt.close()

# Optional py3Dmol
if HAVE_PY3DMOL:
    for key in predicted_pdbs:
        print(f"\nInteractive overlay: {key}")
        view=py3Dmol.view(width=800,height=500)
        view.addModel(predicted_pdbs[key],"pdb");view.setStyle({'model':0},{'cartoon':{'color':'spectrum'}})
        view.addModel(experimental_pdbs[key],"pdb");view.setStyle({'model':1},{'stick':{}})
        view.zoomTo();view.show()

# ---------------------------
# 10) Research summary table
# ---------------------------
table_rows=[]
for key in predicted_pdbs:
    length=len(sequences_filtered[int(key.replace('SEQ',''))-1])
    rmsd=summary.loc[summary['sequence']==key,'rmsd'].values[0]
    avg_per_res=float(np.mean(per_residue[key])) if key in per_residue else None
    feats=seq_feat_df.iloc[int(key.replace('SEQ',''))-1][['hydrophobic_fraction','charged_fraction']].to_dict()
    table_rows.append({
        'Sequence ID':key,
        'Length':length,
        'RMSD (√Ö)':round(rmsd,3) if rmsd is not None else None,
        'Avg per-residue RMSD (√Ö)':round(avg_per_res,3) if avg_per_res is not None else None,
        'Hydrophobic Fraction':round(feats['hydrophobic_fraction'],3),
        'Charged Fraction':round(feats['charged_fraction'],3)
    })

research_table=pd.DataFrame(table_rows).sort_values(by='RMSD (√Ö)').reset_index(drop=True)
from IPython.display import display
print("üß¨ Research Summary Table:")
display(research_table)

print("‚úÖ All outputs saved in ./outputs/ (plots, PCA, per-residue plots).")

from google.colab import sheets
sheet = sheets.InteractiveSheet(df=research_table)

# ---------------------------
# 7) Visualizations (fixed)
# ---------------------------
import matplotlib
import matplotlib.pyplot as plt

# RMSD barplot + histogram
plt.figure(figsize=(12,5))

plt.subplot(1,2,1)
plt.bar(summary["sequence"],summary["rmsd"], color='skyblue')
plt.ylabel("RMSD (√Ö)"); plt.xlabel("Sequence")
plt.title("RMSD per Sequence")

plt.subplot(1,2,2)
plt.hist(summary["rmsd"].dropna(), bins=len(summary), color='salmon', edgecolor='black')
plt.xlabel("RMSD (√Ö)"); plt.ylabel("Count")
plt.title("RMSD Distribution")

plt.tight_layout()
plt.show()

# Boxplot
plt.figure(figsize=(6,4))
plt.boxplot(summary["rmsd"].dropna())
plt.ylabel("RMSD (√Ö)")
plt.title("RMSD Boxplot")
plt.show()

# Correlation heatmap
numeric_df = full_df.select_dtypes(include=[np.number])
plt.figure(figsize=(10,8))
sns.heatmap(numeric_df.corr(), annot=True, cmap='coolwarm', fmt=".2f")
plt.title("Correlation Features vs RMSD")
plt.show()

# Per-residue plots
for key in predicted_pdbs:
    if key in per_residue:
        plt.figure(figsize=(10,3))
        plt.plot(per_residue[key], marker='o', linestyle='-', color='blue')
        plt.title(f'Per-residue CA Distance: {key}')
        plt.xlabel('Residue Index'); plt.ylabel('Distance (√Ö)'); plt.grid(True)
        plt.show()

# PCA 3D scatter (Predicted vs Experimental)
from mpl_toolkits.mplot3d import Axes3D

for key in predicted_pdbs:
    P = pdb_to_ca_coords(predicted_pdbs[key])
    Q = pdb_to_ca_coords(experimental_pdbs[key])
    if len(P) > 2:
        combined = np.vstack([P,Q])
        proj = PCA(n_components=3).fit_transform(combined)
        projP = proj[:P.shape[0]]
        projQ = proj[P.shape[0]:]

        fig = plt.figure(figsize=(7,6))
        ax = fig.add_subplot(111, projection='3d')
        ax.scatter(projP[:,0], projP[:,1], projP[:,2], c='red', label='Predicted', s=30)
        ax.scatter(projQ[:,0], projQ[:,1], projQ[:,2], c='green', label='Experimental', s=30)
        ax.set_title(f'3D PCA of CA coords: {key}')
        ax.legend()
        plt.show()

# py3Dmol interactive overlay (only works in Colab)
if HAVE_PY3DMOL:
    for key in predicted_pdbs:
        print(f"\nInteractive overlay: {key}")
        view = py3Dmol.view(width=800,height=500)
        view.addModel(predicted_pdbs[key], 'pdb')
        view.setStyle({'model':0}, {'cartoon':{'color':'spectrum'}})
        view.addModel(experimental_pdbs[key], 'pdb')
        view.setStyle({'model':1}, {'stick':{}})
        view.zoomTo()
        display(view)  # Important: use display() in Colab

# ---------------------------
# üîπ Fixed Additional Visualizations
# ---------------------------
import seaborn as sns

# 1) Hydrophobic vs Charged fraction colored by RMSD
plt.figure(figsize=(7,5))
sns.scatterplot(data=research_table, x='Hydrophobic Fraction', y='Charged Fraction',
                hue='RMSD (√Ö)', palette='viridis', s=100)
plt.title("Hydrophobic vs Charged Fraction (RMSD colored)")
plt.xlabel("Hydrophobic Fraction"); plt.ylabel("Charged Fraction")
plt.show()  # Seaborn legend shows RMSD automatically

# 2) Sequence length vs RMSD
plt.figure(figsize=(7,5))
sns.scatterplot(data=research_table, x='Length', y='RMSD (√Ö)', hue='RMSD (√Ö)', palette='coolwarm', s=100)
plt.title("Sequence Length vs RMSD")
plt.xlabel("Sequence Length"); plt.ylabel("RMSD (√Ö)")
plt.show()

# 3) Per-residue RMSD heatmaps
for key in per_residue:
    plt.figure(figsize=(10,1))
    plt.imshow(per_residue[key][np.newaxis,:], aspect='auto', cmap='Reds')
    plt.colorbar(label='Distance (√Ö)')
    plt.title(f'Per-residue RMSD Heatmap: {key}')
    plt.xlabel('Residue Index'); plt.yticks([])
    plt.show()

# 4) RMSD trend across sequences
plt.figure(figsize=(8,4))
plt.plot(research_table['Sequence ID'], research_table['RMSD (√Ö)'], marker='o', linestyle='-', color='purple')
plt.title("RMSD Trend Across Sequences")
plt.xlabel("Sequence ID"); plt.ylabel("RMSD (√Ö)")
plt.grid(True)
plt.show()

numeric_cols = ['Length', 'Hydrophobic Fraction', 'Charged Fraction', 'RMSD (√Ö)', 'Avg per-residue RMSD (√Ö)']
sns.pairplot(research_table[numeric_cols], kind='scatter', corner=True, plot_kws={'s':50, 'alpha':0.7})
plt.suptitle("Pairplot of Features vs RMSD", y=1.02)
plt.show()


# 6) Interactive 3D overlay for all sequences
if HAVE_PY3DMOL:
    for key in predicted_pdbs:
        print(f"\nInteractive 3D Overlay: {key}")
        view = py3Dmol.view(width=900, height=500)
        view.addModel(predicted_pdbs[key], 'pdb')
        view.setStyle({'model':0}, {'cartoon':{'color':'spectrum'}})
        view.addModel(experimental_pdbs[key], 'pdb')
        view.setStyle({'model':1}, {'stick':{}})
        view.zoomTo()
        display(view)

numeric_cols = ['Length', 'Hydrophobic Fraction', 'Charged Fraction', 'RMSD (√Ö)', 'Avg per-residue RMSD (√Ö)']
sns.pairplot(research_table[numeric_cols], kind='scatter', corner=True, plot_kws={'s':50, 'alpha':0.7})
plt.suptitle("Pairplot of Features vs RMSD", y=1.02)
plt.show()